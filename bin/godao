#!/usr/bin/env python


from collections import OrderedDict
import json
import os
import re
import subprocess
import sys

from mako.template import Template
import yaml
import yamlordereddictloader


RE_ID = r"[_a-zA-Z][_a-zA-Z0-9]*"
CRE_NAME = re.compile(r"^{}$".format(RE_ID))

CRE_STR_ANNOT = re.compile(r"""
%s
(
    \{{
        str
        \:
        ({id})
        (
            \(
                (?:
                    (?:
                        {id}
                        ,
                    )*
                    {id}
                )?
            \)
        )?
    \}}
)
""".format(id=RE_ID).replace("\n", "").replace(" ", ""))

CRE_IN_ANNOT = re.compile(r"""
\?
(
    \{{
    in
    \:
    (
        {id}
        (?:
            \.
            {id}
        )?
    )
    \}}
)
""".format(id=RE_ID).replace("\n", "").replace(" ", ""))

CRE_OUT_ANNOT = re.compile(r"""
({id})
(
    \{{
    out
    \:
    ({id})
    \}}
)
""".format(id=RE_ID).replace("\n", "").replace(" ", ""))

KIND_FLAG_NULLABLE = 1
KIND_FLAG_ARRAY = 2

KIND_BOOL          = 1 << 2
KIND_NULL_BOOL     = KIND_BOOL | KIND_FLAG_NULLABLE
KIND_BOOL_ARRAY    = KIND_BOOL | KIND_FLAG_ARRAY
KIND_INT           = 2 << 2
KIND_NULL_INT      = KIND_INT | KIND_FLAG_NULLABLE
KIND_INT_ARRAY     = KIND_INT | KIND_FLAG_ARRAY
KIND_UINT          = 3 << 2
KIND_NULL_UINT     = KIND_UINT | KIND_FLAG_NULLABLE
KIND_UINT_ARRAY    = KIND_UINT | KIND_FLAG_ARRAY
KIND_INT8          = 3 << 2
KIND_NULL_INT8     = KIND_INT8 | KIND_FLAG_NULLABLE
KIND_INT8_ARRAY    = KIND_INT8 | KIND_FLAG_ARRAY
KIND_UINT8         = 4 << 2
KIND_NULL_UINT8    = KIND_UINT8 | KIND_FLAG_NULLABLE
KIND_UINT8_ARRAY   = KIND_UINT8 | KIND_FLAG_ARRAY
KIND_INT16         = 5 << 2
KIND_NULL_INT16    = KIND_INT16 | KIND_FLAG_NULLABLE
KIND_INT16_ARRAY   = KIND_INT16 | KIND_FLAG_ARRAY
KIND_UINT16        = 6 << 2
KIND_NULL_UINT16   = KIND_UINT16 | KIND_FLAG_NULLABLE
KIND_UINT16_ARRAY  = KIND_UINT16 | KIND_FLAG_ARRAY
KIND_INT32         = 7 << 2
KIND_NULL_INT32    = KIND_INT32 | KIND_FLAG_NULLABLE
KIND_INT32_ARRAY   = KIND_INT32 | KIND_FLAG_ARRAY
KIND_UINT32        = 8 << 2
KIND_NULL_UINT32   = KIND_UINT32 | KIND_FLAG_NULLABLE
KIND_UINT32_ARRAY  = KIND_UINT32 | KIND_FLAG_ARRAY
KIND_INT64         = 9 << 2
KIND_NULL_INT64    = KIND_INT64 | KIND_FLAG_NULLABLE
KIND_INT64_ARRAY   = KIND_INT64 | KIND_FLAG_ARRAY
KIND_UINT64        = 10 << 2
KIND_NULL_UINT64   = KIND_UINT64 | KIND_FLAG_NULLABLE
KIND_UINT64_ARRAY  = KIND_UINT64 | KIND_FLAG_ARRAY
KIND_FLOAT32       = 11 << 2
KIND_NULL_FLOAT32  = KIND_FLOAT32 | KIND_FLAG_NULLABLE
KIND_FLOAT32_ARRAY = KIND_FLOAT32 | KIND_FLAG_ARRAY
KIND_FLOAT64       = 12 << 2
KIND_NULL_FLOAT64  = KIND_FLOAT64 | KIND_FLAG_NULLABLE
KIND_FLOAT64_ARRAY = KIND_FLOAT64 | KIND_FLAG_ARRAY
KIND_BYTES         = 13 << 2
KIND_STRING        = 14 << 2
KIND_BYTES_ARRAY   = KIND_BYTES | KIND_FLAG_ARRAY
KIND_NULL_STRING   = KIND_STRING | KIND_FLAG_NULLABLE
KIND_STRING_ARRAY  = KIND_STRING | KIND_FLAG_ARRAY
KIND_TIME          = 15 << 2
KIND_NULL_TIME     = KIND_TIME | KIND_FLAG_NULLABLE
KIND_TIME_ARRAY    = KIND_TIME | KIND_FLAG_ARRAY

TYPES_AND_KINDS = (
    ("bool", KIND_BOOL),
    ("bool*", KIND_NULL_BOOL),
    ("bool[]", KIND_BOOL_ARRAY),
    ("int", KIND_INT),
    ("int*", KIND_NULL_INT),
    ("int[]", KIND_INT_ARRAY),
    ("uint", KIND_UINT),
    ("uint*", KIND_NULL_UINT),
    ("uint[]", KIND_UINT_ARRAY),
    ("int8", KIND_INT8),
    ("int8*", KIND_NULL_INT8),
    ("int8[]", KIND_INT8_ARRAY),
    ("uint8", KIND_UINT8),
    ("uint8*", KIND_NULL_UINT8),
    ("uint8[]", KIND_UINT8_ARRAY),
    ("int16", KIND_INT16),
    ("int16*", KIND_NULL_INT16),
    ("int16[]", KIND_INT16_ARRAY),
    ("uint16", KIND_UINT16),
    ("uint16*", KIND_NULL_UINT16),
    ("uint16[]", KIND_UINT16_ARRAY),
    ("int32", KIND_INT32),
    ("int32*", KIND_NULL_INT32),
    ("int32[]", KIND_INT32_ARRAY),
    ("uint32", KIND_UINT32),
    ("uint32*", KIND_NULL_UINT32),
    ("uint32[]", KIND_UINT32_ARRAY),
    ("int64", KIND_INT64),
    ("int64*", KIND_NULL_INT64),
    ("int64[]", KIND_INT64_ARRAY),
    ("uint64", KIND_UINT64),
    ("uint64*", KIND_NULL_UINT64),
    ("uint64[]", KIND_UINT64_ARRAY),
    ("float32", KIND_FLOAT32),
    ("float32*", KIND_NULL_FLOAT32),
    ("float32[]", KIND_FLOAT32_ARRAY),
    ("float64", KIND_FLOAT64),
    ("float64*", KIND_NULL_FLOAT64),
    ("float64[]", KIND_FLOAT64_ARRAY),
    ("bytes", KIND_BYTES),
    ("bytes[]", KIND_BYTES_ARRAY),
    ("string", KIND_STRING),
    ("string*", KIND_NULL_STRING),
    ("string[]", KIND_STRING_ARRAY),
    ("time", KIND_TIME),
    ("time*", KIND_NULL_TIME),
    ("time[]", KIND_TIME_ARRAY),
)

TYPE_2_KIND = {type_: kind for type_, kind in TYPES_AND_KINDS}
KIND_2_TYPE = {kind: type_ for type_, kind in TYPES_AND_KINDS}

KIND_2_GO_TYPE = {
    KIND_BOOL: "bool",
    KIND_NULL_BOOL: "sql.NullBool",
    KIND_BOOL_ARRAY: "[]bool",
    KIND_INT: "int",
    KIND_NULL_INT: "sql.NullInt64",
    KIND_INT_ARRAY: "[]int",
    KIND_UINT: "uint",
    KIND_NULL_UINT: "sql.NullInt64",
    KIND_UINT_ARRAY: "[]uint",
    KIND_INT8: "int8",
    KIND_NULL_INT8: "sql.NullInt64",
    KIND_INT8_ARRAY: "[]int8",
    KIND_UINT8: "uint8",
    KIND_NULL_UINT8: "sql.NullInt64",
    KIND_UINT8_ARRAY: "[]uint8",
    KIND_INT16: "int16",
    KIND_NULL_INT16: "sql.NullInt64",
    KIND_INT16_ARRAY: "[]int16",
    KIND_UINT16: "uint16",
    KIND_NULL_UINT16: "sql.NullInt64",
    KIND_UINT16_ARRAY: "[]uint16",
    KIND_INT32: "int32",
    KIND_NULL_INT32: "sql.NullInt64",
    KIND_INT32_ARRAY: "[]int32",
    KIND_UINT32: "uint32",
    KIND_NULL_UINT32: "sql.NullInt64",
    KIND_UINT32_ARRAY: "[]uint32",
    KIND_INT64: "int64",
    KIND_NULL_INT64: "sql.NullInt64",
    KIND_INT64_ARRAY: "[]int64",
    KIND_UINT64: "uint64",
    KIND_NULL_UINT64: "sql.NullInt64",
    KIND_UINT64_ARRAY: "[]uint64",
    KIND_FLOAT32: "float32",
    KIND_NULL_FLOAT32: "sql.NullFloat64",
    KIND_FLOAT32_ARRAY: "[]float32",
    KIND_FLOAT64: "float64",
    KIND_NULL_FLOAT64: "sql.NullFloat64",
    KIND_FLOAT64_ARRAY: "[]float64",
    KIND_BYTES: "[]byte",
    KIND_BYTES_ARRAY: "[][]byte",
    KIND_STRING: "string",
    KIND_NULL_STRING: "sql.NullString",
    KIND_STRING_ARRAY: "[]string",
    KIND_TIME: "time.Time",
    KIND_NULL_TIME: "mysql.NullTime",
    KIND_TIME_ARRAY: "[]time.Time",
}


class Config(object):
    @classmethod
    def load(cls, parent, path, raw):
        must_be_dict(path, raw)
        instance = cls(parent, path)
        instance.package_name = must_be_str(path + ["package_name"], raw.get("package_name"))

        for k, v in raw.items():
            if isinstance(k, str) and k.startswith("$"):
                dao_name = k[1:]
                instance.daos[dao_name] = DAOConfig.load(instance, path + [k], dao_name, v)

        return instance

    def __init__(self, parent, path):
        self.parent = parent
        self.path = path
        self.package_name = None
        self.daos = OrderedDict()

    def resolve(self, context):
        for dao in self.daos.values():
            dao.resolve(context)

    def emit_code(self, context):
        code = Template("""\
/*
 * Generated by Godao. DO NOT EDIT!
 */

package ${root.package_name}

import (
    "context"
    "database/sql"
    "fmt"
    "time"

    "github.com/go-sql-driver/mysql"
    "github.com/jmoiron/sqlx"
)

var (
    _ = fmt.Sprintf
    _ time.Time
    _ mysql.NullTime
)
""").render(
            root=self,
        )

        for dao in self.daos.values():
            code += dao.emit_code(context)

        code += Template("""\
% for struct_type_name, struct_type_def in context_.struct_type_defs.items():

type ${struct_type_name} struct {
%     for field_name, field_kind in struct_type_def.items():
    ${field_name} ${context_.kind_to_go_type(field_kind)}
%     endfor
}
% endfor
""").render(
            context_=context,
        )

        return code


class DAOConfig(object):
    @classmethod
    def load(cls, parent, path, name, raw):
        check_name(path, name)
        must_be_dict(path, raw)
        instance = cls(parent, path, name)
        path.append("strings")
        raw_strings = must_be_dict(path, raw.get(path[-1], {}))

        for k, v in raw_strings.items():
            if isinstance(k, str) and k.startswith("$"):
                string_name = k[1:]
                instance.strings[string_name] = StringConfig.load(instance, path + [k], string_name, v)

        del path[-1]

        for k, v in raw.items():
            if isinstance(k, str) and k.startswith("$"):
                method_name = k[1:]
                instance.methods[method_name] = MethodConfig.load(instance, path + [k], method_name, v)

        return instance

    def __init__(self, parent, path, name):
        self.parent = parent
        self.path = path
        self.name = name
        self.strings = OrderedDict()
        self.methods = OrderedDict()

    def resolve(self, context):
        for string in self.strings.values():
            string.resolve(context)

        for method in self.methods.values():
            method.resolve(context)

    def emit_code(self, context):
        code = Template("""\
% if any(string.value is not None for string in dao.strings.values()):

const (
%     for string in dao.strings.values():
%         if string.value is not None:
   ${make_string_constant_name(dao.name, string.name)} = "${string.value}"
%         endif
%     endfor
)
% endif

type ${dao.name} struct {
    db *sqlx.DB
}

func (self ${dao.name}) Tx(context_ context.Context, txOptions *sql.TxOptions, callback func(${dao.name}Tx) error) error {
    tx, e := self.db.BeginTxx(context_, txOptions)

    if e != nil {
        return e
    }

    txIsCommitted := false

    defer func() {
        if !txIsCommitted {
            tx.Rollback()
        }
    }()

    if e := callback(${dao.name}Tx(tx)); e != nil {
        return e
    }

    if e := tx.Commit(); e != nil {
        return e
    }

    txIsCommitted = true;
    return nil
}

type ${dao.name}Tx *sqlx.Tx

func Make${dao.name}(db *sqlx.DB) ${dao.name} {
    return ${dao.name}{db}
}
""").render(
            dao=self,
            make_string_constant_name=make_string_constant_name,
        )

        for method in self.methods.values():
            code += method.emit_code(context)

        return code


class StringConfig(object):
    @classmethod
    def load(cls, parent, path, name, raw):
        check_name(path, name)
        must_be_dict(path, raw)
        instance = cls(parent, path, name)
        value = raw.get("value")
        maker_func_name = raw.get("maker_func_name")

        if value is None and maker_func_name is None:
            raise InvalidConfigError(path, "either `value` or `maker_func_name` required")

        if value is not None:
            instance.value = must_be_str(path + ["value"], value)

        if maker_func_name is not None:
            instance.maker_func_name = check_name(path + ["maker_func_name"], maker_func_name)

        return instance

    def __init__(self, parent, path, name):
        self.parent = parent
        self.path = path
        self.name = name
        self.value = None
        self.maker_func_name = None

    def resolve(self, context):
        pass


class MethodConfig(object):
    @classmethod
    def load(cls, parent, path, name, raw):
        check_name(path, name)
        must_be_dict(path, raw)
        instance = cls(parent, path, name)
        instance.input = InputConfig.load(instance, path + ["input"], raw.get("input"))
        instance.output = OutputConfig.load(instance, path + ["output"], raw.get("output"))
        instance.sql = SQLConfig.load(instance, path + ["sql"], raw.get("sql"))
        return instance

    def __init__(self, parent, path, name):
        self.parent = parent
        self.path = path
        self.name = name
        self.input = None
        self.output = None
        self.sql = None

    def resolve(self, context):
        self.input.resolve(context)
        self.output.resolve(context)
        self.sql.resolve(context)

    def emit_code(self, context):
        class Counter(Visitor):
            def __init__(self):
                super(Counter, self).__init__()
                self.max_number_of_str_annots = 0
                self.max_number_of_in_annots = 0
                self.max_number_of_out_annots = 0
                self.max_query_size = 0
                self._str_annot_count = 0
                self._in_annot_count = 0
                self._out_annot_count = 0
                self._query_size = 0

            def visit_if_statement(self, statement):
                backup = self._out_annot_count, self._in_annot_count, self._out_annot_count, self._query_size

                for _, then_body in statement.conds_and_then_bodies:
                    then_body.accept_visit(self)
                    self._out_annot_count, self._in_annot_count, self._out_annot_count, self._query_size = backup

                if statement.else_body is not None:
                    statement.else_body.accept_visit(self)

                self._str_annot_count, self._in_annot_count, self._out_annot_count, self._query_size = \
                    self.max_number_of_str_annots, \
                    self.max_number_of_in_annots, \
                    self.max_number_of_out_annots, \
                    self.max_query_size
                return False

            def visit_text_statement(self, statement):
                self._str_annot_count += len(statement.str_annots)
                self._in_annot_count += len(statement.in_annots)
                self._out_annot_count += len(statement.out_annots)
                self._query_size += statement.lines_size

                if self._str_annot_count > self.max_number_of_str_annots:
                    self.max_number_of_str_annots = self._str_annot_count

                if self._in_annot_count > self.max_number_of_in_annots:
                    self.max_number_of_in_annots = self._in_annot_count

                if self._out_annot_count > self.max_number_of_out_annots:
                    self.max_number_of_out_annots = self._out_annot_count

                if self._query_size > self.max_query_size:
                    self.max_query_size = self._query_size

                return True

        counter = Counter()
        self.sql.program.accept_visit(counter)
        method = self
        dao = method.parent

        if self.output.reduced_result_kind is None:
            reduced_result_go_type = None
        else:
            reduced_result_go_type = context.kind_to_go_type(self.output.reduced_result_kind)

        if len(self.output.results) == 0:
            result_zero = "sql.Result(nil)"
        else:
            if self.output.select_one and not kind_is_struct(self.output.reduced_result_kind):
                result_zero = {
                    KIND_BOOL: "false",
                    KIND_BYTES: "nil",
                    KIND_STRING: "\"\"",
                    KIND_TIME: "time.Time{}",
                }.get(self.output.reduced_result_kind, "0")
            else:
                result_zero = "nil"

        class CodeGenerator(Visitor):
            def __init__(self, line_prefix, indent):
                self._line_prefix = line_prefix
                self._indent = indent
                self._lines = []

            def get_output(self):
                return "\n".join(self._lines)

            def visit_program(self, program):
                self._output_line("_buffer1 := [{}]byte{{}}".format(counter.max_query_size))
                self._output_line("_raw_query := _buffer1[:0]")

                if counter.max_number_of_str_annots >= 1:
                    self._output_line("_buffer2 := [{}]interface{{}}{{}}".format(counter.max_number_of_str_annots))
                    self._output_line("_query_substrs := _buffer2[:0]")

                if counter.max_number_of_in_annots >= 1:
                    self._output_line("_buffer3 := [{}]interface{{}}{{}}".format(counter.max_number_of_in_annots))
                    self._output_line("_args := _buffer3[:0]")

                    if method.sql.has_array_query_args:
                        self._output_line("_expand_args := false")

                if counter.max_number_of_out_annots >= 1:
                    if kind_is_struct(method.output.reduced_result_kind):
                        self._output_line("var _buffer4 {}".format(reduced_result_go_type[1:]))
                        self._output_line("_record := &_buffer4")
                    else:
                        self._output_line("var _record {}".format(reduced_result_go_type))

                    self._output_line("_buffer5 := [{}]interface{{}}{{}}".format(counter.max_number_of_out_annots))
                    self._output_line("_results := _buffer5[:0]")

                for statement in program.body:
                    statement.accept_visit(self)

                if counter.max_number_of_str_annots == 0:
                    self._output_line("_query := string(_raw_query)")
                else:
                    self._output_line("_query := fmt.Sprintf(string(_raw_query), _query_substrs...)")

                    if method.sql.has_array_query_args:
                        self._output_line("if _expand_args {")
                        self._output_line("{}var _e error".format(self._indent))
                        self._output_line("{}_query, _args, _e = sqlx.In(_query, _args...)".format(self._indent))
                        self._output_line("{}if _e != nil {{".format(self._indent))
                        self._output_line("{}{}return {}, _e".format(self._indent, self._indent, result_zero))
                        self._output_line("{}}}".format(self._indent))
                        self._output_line("}")

                if counter.max_number_of_in_annots == 0:
                    args_part = ""
                else:
                    args_part = ", _args..."

                if reduced_result_go_type is None:
                    self._output_line("return execer.ExecContext(context_, _query{})".format(args_part))
                else:
                    if method.output.select_one:
                        self._output_line("if _e := queryer.QueryRowxContext(context_, _query{}).Scan(_results...); _e != nil {{".format(args_part))

                        if method.output.ignore_no_rows:
                            self._output_line("{}if _e == sql.ErrNoRows {{".format(self._indent))
                            self._output_line("{}{}_e = nil".format(self._indent, self._indent))
                            self._output_line("{}}}".format(self._indent))

                        self._output_line("{}return {}, _e".format(self._indent, result_zero))
                        self._output_line("}")
                        self._output_line("return _record, nil")
                    else:
                        self._output_line("_rows, _e := queryer.QueryxContext(context_, _query{})".format(args_part))
                        self._output_line("if _e != nil {")
                        self._output_line("{}return {}, _e".format(self._indent, result_zero))
                        self._output_line("}")
                        self._output_line("_records := []{}(nil)".format(reduced_result_go_type))
                        self._output_line("for _rows.Next() {")
                        self._output_line("{}if _e := _rows.Scan(_results...); _e != nil {{".format(self._indent))
                        self._output_line("{}{}_rows.Close()".format(self._indent, self._indent))
                        self._output_line("{}{}return {}, _e".format(self._indent, self._indent, result_zero))
                        self._output_line("{}}}".format(self._indent))

                        if kind_is_struct(method.output.reduced_result_kind):
                            self._output_line("{}_record_copy := new({})".format(self._indent, reduced_result_go_type[1:]))
                            self._output_line("{}*_record_copy = *_record".format(self._indent))
                            self._output_line("{}_records = append(_records, _record_copy)".format(self._indent))
                        else:
                            self._output_line("{}_records = append(_records, _record)".format(self._indent))

                        self._output_line("}")
                        self._output_line("_rows.Close()")
                        self._output_line("return _records, nil")

                return False

            def visit_if_statement(self, statement):
                cond, then_body = statement.conds_and_then_bodies[0]
                self._output_line("if {} {{".format(cond))
                then_body.accept_visit(self)

                for cond, then_body in statement.conds_and_then_bodies[1:]:
                    self._output_line("}} else if {} {{".format(cond))
                    then_body.accept_visit(self)

                if statement.else_body is not None:
                    self._output_line("} else {")
                    statement.else_body.accept_visit(self)

                self._output_line("}")
                return False

            def visit_block_statement(self, statement):
                self._line_prefix += self._indent

                for statement2 in statement.body:
                    statement2.accept_visit(self)

                self._line_prefix = self._line_prefix[:-len(self._indent)]
                return False

            def visit_text_statement(self, statement):
                self._output_line("_raw_query = append(_raw_query, {}...)".format(statement.lines))

                if len(statement.str_annots) >= 1:
                    query_substrs = []

                    for string_name, param_names in statement.str_annots:
                        if param_names is None:
                            query_substr = make_string_constant_name(dao.name, string_name)
                        else:
                            string = dao.strings[string_name]
                            query_substr = string.maker_func_name + "(context_"

                            if string.value is not None:
                                query_substr += ", " + make_string_constant_name(dao.name, string_name)

                            for param_name in param_names:
                                query_substr += ", " + param_name

                            query_substr += ")"

                        query_substrs.append(query_substr)

                    self._output_line("_query_substrs = append(_query_substrs, {})".format(", ".join(query_substrs)))

                if len(statement.in_annots) >= 1:
                    self._output_line("_args = append(_args, {})".format(", ".join(statement.in_annots)))

                    for param_name in statement.in_annots:
                        param_kind = method.input.expanded_params[param_name]

                        if kind_is_array(param_kind):
                            self._output_line("_expand_args = true")
                            break

                if len(statement.out_annots) >= 1:
                    if kind_is_struct(method.output.reduced_result_kind):
                        results = ("&_record." + result_name for _, result_name in method.sql.out_annots)
                        self._output_line("_results = append(_results, {})".format(", ".join(results)))
                    else:
                        self._output_line("_results = append(_results, &_record)")

                return False

            def _output_line(self, line):
                self._lines.append(self._line_prefix + line)

        code_generator = CodeGenerator("    ", "    ")
        self.sql.program.accept_visit(code_generator)

        code = Template("""\

func (_self ${dao.name}) ${method.name}(context_ context.Context\\
% for param_name, param_kind in method.input.params.items():
, ${param_name} ${context_.kind_to_go_type(param_kind)}\\
% endfor
) (\\
% if reduced_result_go_type is None:
sql.Result\\
% else:
${("" if method.output.select_one else "[]") + reduced_result_go_type}\\
% endif
, error) {
    return _self.do${camel_case_to_pascal_case(method.name) if is_camel_case(method.name) else method.name}(_self.db, context_\\
% for param_name in method.input.params.keys():
, ${param_name}\\
% endfor
)
}

func (_self ${dao.name}) ${"tx" + camel_case_to_pascal_case(method.name) if is_camel_case(method.name) else "Tx" + method.name}(\\
tx ${dao.name}Tx, context_ context.Context\\
% for param_name, param_kind in method.input.params.items():
, ${param_name} ${context_.kind_to_go_type(param_kind)}\\
% endfor
) (\\
% if reduced_result_go_type is None:
sql.Result\\
% else:
${("" if method.output.select_one else "[]") + reduced_result_go_type}\\
% endif
, error) {
    return _self.do${camel_case_to_pascal_case(method.name) if is_camel_case(method.name) else method.name}((*sqlx.Tx)(tx), context_\\
% for i, param_name in enumerate(method.input.params.keys()):
, ${param_name}\\
% endfor
)
}

func (${dao.name}) do${camel_case_to_pascal_case(method.name) if is_camel_case(method.name) else method.name}(\\
${"execer sqlx.ExecerContext" if reduced_result_go_type is None else "queryer sqlx.QueryerContext"}, context_ context.Context\\
% for param_name, param_kind in method.input.params.items():
, ${param_name} ${context_.kind_to_go_type(param_kind)}\\
% endfor
) (\\
% if reduced_result_go_type is None:
sql.Result\\
% else:
${("" if method.output.select_one else "[]") + reduced_result_go_type}\\
% endif
, error) {
% for line in method.sql.raw.split("\\n"):
     // ${line}
% endfor
${impl_code}
}
""").render(
            method=self,
            dao=self.parent,
            context_=context,
            reduced_result_go_type=reduced_result_go_type,
            is_camel_case=is_camel_case,
            camel_case_to_pascal_case=camel_case_to_pascal_case,
            impl_code=code_generator.get_output(),
        )

        return code


class InputConfig(object):
    @classmethod
    def load(cls, parent, path, raw):
        instance = cls(parent, path)

        if raw is not None:
            must_be_dict(path, raw)

            for k, v in raw.items():
                if isinstance(k, str) and k.startswith("$"):
                    param_name = check_name(path + [k], k[1:])

                    if isinstance(v, OrderedDict):
                        instance.params[param_name] = parse_struct_type_config(path + [k], v)
                    else:
                        instance.params[param_name] = parse_type(path + [k], v)

        return instance

    def __init__(self, parent, path):
        self.parent = parent
        self.path = path
        self.params = OrderedDict()

        self.expanded_params = OrderedDict()

    def resolve(self, context):
        for param_name, maybe_param_kind in tuple(self.params.items()):
            if isinstance(maybe_param_kind, int):
                self.expanded_params[param_name] = maybe_param_kind
            else:
                struct_type_name, struct_type_def = maybe_param_kind
                param_kind = context.define_struct_type(self.path, struct_type_name, struct_type_def)
                self.params[param_name] = param_kind

                for field_name, field_kind in struct_type_def.items():
                    self.expanded_params[param_name + "." + field_name] = field_kind

        method = self.parent
        used_param_names = set()

        for _, param_names in method.sql.str_annots:
            if param_names is not None:
                used_param_names.update(param_names)

        for param_name in method.sql.in_annots:
            used_param_names.add(param_name)

        for param_name in set(self.expanded_params.keys()) - used_param_names:
            raise InvalidConfigError(self.path, "param {!r} unused".format(param_name))


class OutputConfig(object):
    @classmethod
    def load(cls, parent, path, raw):
        instance = cls(parent, path)

        if raw is not None:
            must_be_dict(path, raw)

            for k, v in raw.items():
                if isinstance(k, str) and k.startswith("$"):
                    result_name = check_name(path + [k], k[1:])
                    instance.results[result_name] = parse_type(path + [k], v)

            if "struct_type_name" in raw:
                instance.struct_type_name = check_name(path + ["struct_type_name"], raw["struct_type_name"])

            instance.select_one = must_be_bool(path + ["select_one"], raw.get("select_one", False))
            instance.ignore_no_rows = must_be_bool(path + ["ignore_no_rows"], raw.get("ignore_no_rows", False))

        return instance

    def __init__(self, parent, path):
        self.parent = parent
        self.path = path
        self.results = OrderedDict()
        self.struct_type_name = None
        self.select_one = None
        self.ignore_no_rows = None

        self.reduced_result_kind = None

    def resolve(self, context):
        method = self.parent
        used_result_names = set()

        for _, result_name in method.sql.out_annots:
            used_result_names.add(result_name)

        for result_name in set(self.results.keys()) - used_result_names:
            raise InvalidConfigError(self.path, "result {!r} unused".format(result_name))

        for result_name, result_kind in self.results.items():
            if kind_is_array(result_kind):
                raise InvalidConfigError(self.path, "result {!r} should not be array".format(result_name))

        if len(self.results) == 0 and self.struct_type_name is not None:
            raise InvalidConfigError(self.path, "useless struct type name: value={!r}".format(self.struct_type_name))

        if len(self.results) >= 2 and self.struct_type_name is None:
            raise InvalidConfigError(self.path, "missing struct type name")

        if len(self.results) >= 1:
            if self.struct_type_name is None:
                (_, self.reduced_result_kind), = self.results.items()
            else:
                self.reduced_result_kind = context.define_struct_type(self.path, self.struct_type_name, self.results)


class SQLConfig(object):
    @classmethod
    def load(cls, parent, path, raw):
        raw = must_be_str(path, raw).rstrip()
        instance = cls(parent, path, raw)
        instance.program = Preprocessor(path, raw).get_program()

        class AnnotCollector(Visitor):
            def __init__(self):
                super(AnnotCollector, self).__init__()

            def visit_text_statement(self, statement):
                instance.str_annots.extend(statement.str_annots)
                instance.in_annots.extend(statement.in_annots)
                instance.out_annots.extend(statement.out_annots)
                return True

        instance.program.accept_visit(AnnotCollector())
        return instance

    def __init__(self, parent, path, raw):
        self.parent = parent
        self.path = path
        self.raw = raw
        self.program = None
        self.str_annots = []
        self.in_annots = []
        self.out_annots = []

        self.has_array_query_args = None

    def resolve(self, context):
        method = self.parent
        dao = method.parent

        for string_name, param_names in self.str_annots:
            string = dao.strings.get(string_name)

            if string is None:
                raise InvalidConfigError(self.path, "string {!r} undefined".format(string_name))

            if param_names is None:
                if string.maker_func_name is not None:
                    raise InvalidConfigError(self.path, "str:{} => must call with argument list (...)".format(string_name))
            else:
                if string.maker_func_name is None:
                    raise InvalidConfigError(self.path, "str:{} => can not call with argument list ({})".format(string_name, ",".join(param_names)))

                for param_name in param_names:
                    if param_name not in method.input.expanded_params:
                        raise InvalidConfigError(self.path, "param {!r} undefined".format(param_name))

        for param_name in self.in_annots:
            if param_name not in method.input.expanded_params:
                raise InvalidConfigError(self.path, "param {!r} undefined".format(param_name))

        used_result_names = set()

        for _, result_name in self.out_annots:
            if result_name not in method.output.results:
                raise InvalidConfigError(self.path, "result {!r} undefined".format(result_name))

            if result_name in used_result_names:
                raise InvalidConfigError(self.path, "result {!r} reused".format(result_name))

            used_result_names.add(result_name)

        for param_name in self.in_annots:
            param_kind = method.input.expanded_params[param_name]

            if kind_is_array(param_kind):
                self.has_array_query_args = True
                break
        else:
            self.has_array_query_args = False


class Preprocessor(object):
    def __init__(self, path, source):
        self._path = path
        self._lines = source.split("\n")
        self._next_line_index = 0

    def get_program(self):
        program = Program()

        while True:
            _, ok = self._peek_line()

            if not ok:
                return program

            program.body.append(self._get_statement())

    def _get_statement(self):
        line, _ = self._peek_line()

        if line.startswith("#"):
            match = re.match(r"#\s*if", line)

            if match is not None:
                return self._get_if_statement()

            self._skip_line()
            self._abort("invalid directive")
        else:
            return self._get_text_statement()

    def _get_if_statement(self):
        statement = IfStatement()
        line = self._read_line()
        match = re.match(r"#\s*if\s+([^\s].*?)\s*$", line)

        if match is None:
            self._abort("#if ... directive expected")

        statement.conds_and_then_bodies.append((
            match.group(1),
            self._get_block_statement(r"#\s*(else|elif|endif)")
        ))

        line, _ = self._peek_line()

        while True:
            match = re.match(r"#\s*elif\s+([^\s].*?)\s*$", line)

            if match is None:
                if re.match(r"#\s*elif", line) is not None:
                    self._abort("#elif ... directive expected")

                break

            self._skip_line()

            statement.conds_and_then_bodies.append((
                match.group(1),
                self._get_block_statement(r"#\s*(else|elif|endif)")
            ))

            line, _ = self._peek_line()

        if re.match(r"#\s*else\s*$", line) is None:
            if re.match(r"#\s*else", line) is not None:
                self._abort("#else directive expected")
        else:
            self._skip_line()
            statement.else_body = self._get_block_statement(r"#\s*endif")
            line, _ = self._peek_line()

        if re.match(r"#\s*endif\s*$", self._read_line()) is None:
            self._abort("#endif directive expected")

        return statement

    def _get_block_statement(self, stop_line_pattern):
        statement = BlockStatement()

        while True:
            line, _ = self._peek_line()

            if re.match(stop_line_pattern, line) is not None:
                return statement

            statement.body.append(self._get_statement())

    def _get_text_statement(self):
        statement = TextStatement()
        line = self._read_line()
        lines = []
        lines_size = 0

        while True:
            while True:
                match = CRE_STR_ANNOT.search(line)

                if match is None:
                    break

                if match.group(3) is None:
                    statement.str_annots.append((match.group(2), None))
                else:
                    statement.str_annots.append((match.group(2), match.group(3)[1:-1].split(",")))

                line = line[:match.start(1)] + line[match.end(1):]

            while True:
                match = CRE_IN_ANNOT.search(line)

                if match is None:
                    break

                statement.in_annots.append(match.group(2))
                line = line[:match.start(1)] + line[match.end(1):]

            while True:
                match = CRE_OUT_ANNOT.search(line)

                if match is None:
                    break

                statement.out_annots.append((match.group(1), match.group(3)))
                line = line[:match.start(2)] + line[match.end(2):]

            for c in ("{", "}"):
                i = 0

                while True:
                    i = line.find(c, i)

                    if i < 0:
                        break

                    j = i + 1

                    while j < len(line):
                        if line[j] != c:
                            break

                        j += 1

                    i += (j - i) // 2 * 2

                    if i != j:
                        raise self._abort("bad annots: value=...{!r}".format(line[i:]))

            lines.append(line)
            lines_size += len(bytes(line)) + 1
            line, ok = self._peek_line()

            if not ok or line.startswith("#"):
                break

            self._skip_line()

        statement.lines = json.dumps("\n".join(lines))
        statement.lines_size = lines_size
        return statement

    def _read_line(self):
        if self._next_line_index == len(self._lines):
            self._abort("end of file")

        line = self._lines[self._next_line_index]
        self._next_line_index += 1
        return line

    def _peek_line(self):
        if self._next_line_index == len(self._lines):
            return "", False

        return self._lines[self._next_line_index], True

    def _skip_line(self):
        self._next_line_index += 1

    def _abort(self, message):
        raise InvalidConfigError(self._path, "line {}: {}".format(self._next_line_index, message))


class Program(object):
    def __init__(self):
        self.body = []

    def accept_visit(self, visitor):
        if visitor.visit_program(self):
            for statement in self.body:
                statement.accept_visit(visitor)


class IfStatement(object):
    def __init__(self):
        self.conds_and_then_bodies = []
        self.else_body = None

    def accept_visit(self, visitor):
        if visitor.visit_if_statement(self):
            for _, then_body in self.conds_and_then_bodies:
                then_body.accept_visit(visitor)

            if self.else_body is not None:
                self.else_body.accept_visit(visitor)


class BlockStatement(object):
    def __init__(self):
        self.body = []

    def accept_visit(self, visitor):
        if visitor.visit_block_statement(self):
            for statement in self.body:
                statement.accept_visit(visitor)


class TextStatement(object):
    def __init__(self):
        self.str_annots = []
        self.in_annots = []
        self.out_annots = []
        self.lines = None
        self.lines_size = None

    def accept_visit(self, visitor):
        visitor.visit_text_statement(self)


class Visitor(object):
    def visit_program(self, program):
        return True

    def visit_if_statement(self, statement):
        return True

    def visit_block_statement(self, statement):
        return True

    def visit_text_statement(self, statement):
        return True


class Context(object):
    def __init__(self):
        self.struct_type_defs = OrderedDict()
        self._struct_kinds_and_type_digests = {}
        self._struct_kind_2_go_type = {}

    def define_struct_type(self, path, struct_type_name, struct_type_def):
        struct_type_digest = "struct { "

        for field_name, field_kind in struct_type_def.items():
            field_type = KIND_2_TYPE[field_kind]
            struct_type_digest += "{} {}; ".format(field_type, field_name)

        struct_type_digest += "}"
        struct_kind_and_type_digest = self._struct_kinds_and_type_digests.get(struct_type_name)

        if struct_kind_and_type_digest is None:
            self.struct_type_defs[struct_type_name] = struct_type_def
            struct_kind = -len(self.struct_type_defs)
            self._struct_kinds_and_type_digests[struct_type_name] = struct_kind, struct_type_digest
            self._struct_kind_2_go_type[struct_kind] = "*" + struct_type_name
            return struct_kind
        else:
            struct_kind, struct_type_digest2 = struct_kind_and_type_digest

            if struct_type_digest != struct_type_digest2:
                raise InvalidConfigError(path, "struct type {!r} redefined: {!r} != {!r}"
                                               .format(struct_type_name, struct_type_digest, struct_type_digest2))

            return struct_kind

    def kind_to_go_type(self, kind):
        if kind_is_struct(kind):
            return self._struct_kind_2_go_type[kind]
        else:
            return KIND_2_GO_TYPE[kind]


class InvalidConfigError(Exception):
    def __init__(self, path, message):
        self._path = path
        self._message = message

    def __str__(self):
        return "{}: {}".format(".".join(self._path), self._message)


def load_config(config_text):
    raw_config = yaml.load(config_text, yamlordereddictloader.Loader)
    return Config.load(None, [""], raw_config)


def must_be_bool(path, object_):
    if not isinstance(object_, bool):
        raise InvalidConfigError(path, "must be bool, type={!r}".format(type(object_)))

    return object_


def must_be_str(path, object_):
    if not isinstance(object_, str):
        raise InvalidConfigError(path, "must be str, type={!r}".format(type(object_)))

    return object_


def must_be_list(path, object_):
    if not isinstance(object_, list):
        raise InvalidConfigError(path, "must be list, value={!r}".format(type(object_)))

    return object_


def must_be_dict(path, object_):
    if not isinstance(object_, OrderedDict):
        raise InvalidConfigError(path, "must be dict, value={!r}".format(type(object_)))

    return object_


def check_name(path, name):
    must_be_str(path, name)

    if CRE_NAME.match(name) is None:
        raise InvalidConfigError(path, "invalid name, value={!r}".format(name))

    return name


def parse_type(path, type_):
    must_be_str(path, type_)
    kind = TYPE_2_KIND.get(type_)

    if kind is None:
        raise InvalidConfigError(path, "invalid type, value={!r}, excepted_values={!r}".format(type_, [type_ for type_, _ in TYPES_AND_KINDS]))

    return kind


def parse_struct_type_config(path, struct_type_config):
    struct_type_name = check_name(path + ["struct_type_name"], struct_type_config.get("struct_type_name"))
    struct_type_def = OrderedDict()

    for k, v in struct_type_config.items():
        if isinstance(k, str) and k.startswith("$"):
            field_name = check_name(path + [k], k[1:])
            struct_type_def[field_name] = parse_type(path + [k], v)

    return struct_type_name, struct_type_def


def kind_is_array(kind):
    return kind >= 1 and (kind & KIND_FLAG_ARRAY) != 0


def kind_is_struct(kind):
    return kind < 0


def is_camel_case(name):
    return name[0].islower()


def camel_case_to_pascal_case(name):
    return name[0].upper() + name[1:]


def pascal_case_to_camel_case(name):
    i = 1

    while i < len(name):
        if name[i].islower():
            if i == 1:
                return name[0].lower() + name[1:]
            else:
                return name[:i-1].lower() + name[i-1:]

        i += 1
    else:
        return name.lower()

def make_string_constant_name(dao_name, string_name):
    if is_camel_case(string_name):
        if not is_camel_case(dao_name):
            dao_name = pascal_case_to_camel_case(dao_name)

        string_name = camel_case_to_pascal_case(string_name)

    return "{}_{}".format(dao_name, string_name)


def generate_code(config_text):
    config = load_config(config_text)
    context = Context()
    config.resolve(context)
    code = config.emit_code(context)
    code = format_code(code)
    return code


def format_code(code):
    try:
        process = subprocess.Popen("gofmt", stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
        output, _ = process.communicate(code)

        if process.poll() == os.EX_OK:
            code = output
    except:
        pass

    return code


def main():
    config_text = sys.stdin.read()
    code = generate_code(config_text)
    sys.stdout.write(code)


if __name__ == "__main__":
    main()
